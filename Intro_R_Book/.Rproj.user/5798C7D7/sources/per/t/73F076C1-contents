# 新手上路 R Basics 2

---
output:
  html_document:
    toc: true
    number_sections: false
---


## 为什么要学统计？

不管你是谁，不得不承认，我们所生活的世界，复杂，多变，充满随机性与不确定性。

同时，在这纷繁复杂的表象里面，也蕴含着必然的规律，也可以说是“套路”。

发现这些规律，帮助我们更好的理解我们的世界，作出更正确的决定，做更好的自己，哦耶。

这正是统计学干的事情。

不，我们借统计学干的事情。

[]!(/Users/yuandong/Dropbox/Public/stats.png)

* 幸存者偏差，二战盟军统计学家沃尔德
* 老物件、双盲实验、成功者的故事（从大学退学的特征）
* 不能只看贼吃肉，不看贼挨揍


## 补一点统计知识
描述性统计：Summary statistics 

### 集中趋势统计量:  均值（Mean)、中位数(Median)、众数(Mode)、百分位数(percentile)

* 均值（Mean): 描述数据取值的平均位置，指一组数据的平均数
```{r}
mean(mtcars$mpg)
```

* 中位数(Median): 定义为数据排序位于中间位置的值
```{r}
median(mtcars$mpg)
```

*众数(Mode): 就是一组数据中占比例最多的那个数， R中未提供直接调用的函数
```{r}
names(table(mtcars$mpg))[which.max(table(mtcars$mpg))]
```

*百分位数 (percentile)
```{r}
quantile(mtcars$mpg)
```


### 离散趋势统计量：方差（var)、极差（range)

* 方差（Variance): 是描述数据取值分散性的一个度量.样本方差(sample variance)是样本相对于均值的偏差平方和的平均,记为s2:

$$s2=\frac{1}{n-1}\sum ^n _{i=1} (x_i-\bar{x})^2$$
* 标准差就是方差开方：

$$s=\sqrt{\frac{1}{n-1}\sum ^n _{i=1} (x_i-\bar{x})^2}$$

```{r}
var(mtcars$mpg)
```

* 极差（Range): 描述样本分散性的数字特征.当数据越分散,其极差越大
```{r}
range(mtcars$mpg)
```

```{r}
summary(mtcars$mpg)
```

```{r}
summary(mtcars)
```

## 基本作图
一图胜千言

人类非常善于从视觉呈现中洞察关系。一幅精心绘制的图形能够帮助你在数以千计的零散信 息中做出有意义的比较，提炼出使用其他方法时不那么容易发现的模式。这也是统计图形领域的 进展能够对数据分析产生重大影响的原因之一。数据分析师需要观察他们的数据，而R在该领域 表现出众。（Actions in R）

R是一个惊艳的图形构建平台。在通常的交互式会话中，我们可 以通过逐条输入语句构建图形，逐渐完善图形特征，直至得到想要的效果。

plot()是R中为对象作图的一个泛型函数(它的输出将根据所绘制对象类型的不同而变化)。 


```{r eval=FALSE}
plot(x, y, type="b")
```
将x置于横轴，将y置于纵轴，绘制点集(x, y)，散点图。使用help(plot)可以查看其他选项。


```{r}
plot(mtcars$wt, mtcars$mpg)
abline(lm(mtcars$mpg~mtcars$wt))
title("Regression of MPG on Weight")
```


```{r}
plot(mtcars$wt, mtcars$mpg,
         xlab="Miles Per Gallon",
         ylab="Car Weight")
abline(lm(mtcars$mpg~mtcars$wt))
title("Regression of MPG on Weight")
```

第一条语句打开了一个图形窗口并生成了一幅散点图，横轴表 示车身重量，纵轴为每加仑汽油行驶的英里数。第二句向图形添加了一条最优拟合曲线。第三句 添加了标题。


```{r}
plot(mtcars$wt, mtcars$mpg,
         xlab="Miles Per Gallon",
         ylab="Car Weight",
     col=4)
abline(lm(mtcars$mpg~mtcars$wt))
title("Regression of MPG on Weight")
```

```{r}
plot(mtcars$wt, mtcars$mpg,
         xlab="Miles Per Gallon",
         ylab="Car Weight",
     col=4,
     pch=16)
abline(lm(mtcars$mpg~mtcars$wt))
title("Regression of MPG on Weight")
```


总是用美元符号，是不是太麻烦？换一种方式：
```{r}
with(mtcars,{
plot(wt, mpg)
abline(lm(mpg~wt))
title("Regression of MPG on Weight")
}
)
```


全局参数设定，多图同列, 例如设置2列2行：
```{r eval=FALSE}
par(mfrow=c(3,1))
```

四个直方图：
```{r}
with(mtcars,{
  par(mfrow=c(2,2))
  hist(wt)
  hist(mpg)
  hist(disp)
  hist(hp)
})
```

箱图
```{r}
boxplot(mtcars$mpg)
```

可以通过代码或图形用户界面来保存图形。

要通过代码保存图形，将绘图语句夹在开启目标 图形设备的语句和关闭目标图形设备的语句之间即可。例如，以下代码会将图形保存到当前工作 目录中名为mygraph.pdf的PDF文件中(R in Action):

```{r}
pdf("mygraph.pdf")
      attach(mtcars)
      plot(wt, mpg)
      abline(lm(mpg~wt))
      title("Regression of MPG on Weight")
      detach(mtcars)
dev.off()
```

除了pdf()，还可以使用函数win.metafile()、png()、jpeg()、bmp()等将图形保存为其他格式。

通过图形用户界面保存图形，在RStudio的右下角，"Export"即可。



```{r}

```

```{r}

```


# 数据管理

## 添加变量

## 缺失值处理

## 导入输入

## 脚本

# 掌握R语言中的apply函数族
http://blog.fens.me/r-apply/


刚开始接触R语言时，会听到各种的R语言使用技巧，其中最重要的一条就是不要用循环，效率特别低，要用向量计算代替循环计算。

那么，这是为什么呢？原因在于R的循环操作for和while，都是基于R语言本身来实现的，而向量操作是基于底层的C语言函数实现的，从性能上来看，就会有比较明显的差距了。那么如何使用C的函数来实现向量计算呢，就是要用到apply的家族函数，包括apply, sapply, tapply, mapply, lapply, rapply, vapply, eapply等。


## apply的家族函数
apply函数族是R语言中数据处理的一组核心函数，通过使用apply函数，我们可以实现对数据的循环、分组、过滤、类型控制等操作。但是，由于在R语言中apply函数与其他语言循环体的处理思路是完全不一样的，所以apply函数族一直是使用者玩不转一类核心函数。

很多R语言新手，写了很多的for循环代码，也不愿意多花点时间把apply函数的使用方法了解清楚，最后把R代码写的跟C似得，我严重鄙视只会写for的R程序员。

apply函数本身就是解决数据循环处理的问题，为了面向不同的数据类型，不同的返回值，apply函数组成了一个函数族，包括了8个功能类似的函数。这其中有些函数很相似，有些也不是太一样的。

最常用的函数为apply和sapply，下面将分别介绍这8个函数的定义和使用方法。

## apply函数
apply函数是最常用的代替for循环的函数。apply函数可以对矩阵、数据框、数组(二维、多维)，按行或列进行循环计算，对子元素进行迭代，并把子元素以参数传递的形式给自定义的FUN函数中，并以返回计算结果。

函数定义：

```{r eval=FALSE}
apply(X, MARGIN, FUN, ...)
```

参数列表：

* X:数组、矩阵、数据框
* MARGIN: 按行计算或按按列计算，1表示按行，2表示按列
* FUN: 自定义的调用函数
* …: 更多参数，可选


比如，对一个矩阵的每一行求和，下面就要用到apply做循环了。

```{r}
x<-matrix(1:12,ncol=3)
apply(x,1,sum)
```

下面计算一个稍微复杂点的例子，按行循环，让数据框的x1列加1，并计算出x1,x2列的均值。


生成data.frame
```{r}
x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
x
# 自定义函数myFUN，第一个参数x为数据
# 第二、三个参数为自定义参数，可以通过apply的'...'进行传入。
myFUN<- function(x, c1, c2) {
c(sum(x[c1],1), mean(x[c2])) 
}

# 把数据框按行做循环，每行分别传递给myFUN函数，设置c1,c2对应myFUN的第二、三个参数
apply(x,1,myFUN,c1='x1',c2=c('x1','x2'))
```

通过这个上面的自定义函数myFUN就实现了，一个常用的循环计算。

如果直接用for循环来实现，那么代码如下：
```{r eval=FALSE}
# 定义一个结果的数据框
df<-data.frame()

# 定义for循环
for(i in 1:nrow(x)){
  row<-x[i,]                                         # 每行的值
  df<-rbind(df,rbind(c(sum(row[1],1), mean(row))))    #计算，并赋值到结果数据框
  }

# 打印结果数据框
df
```

通过for循环的方式，也可以很容易的实现上面计算过程，但是这里还有一些额外的操作需要自己处理，比如构建循环体、定义结果数据集、并合每次循环的结果到结果数据集。

对于上面的需求，还有第三种实现方法，那就是完成利用了R的特性，通过向量化计算来完成的。

```{r eval=FALSE}
data.frame(x1=x[,1] 1,x2=rowMeans(x))
```

那么，一行就可以完成整个计算过程了。

接下来，我们需要再比较一下3种操作上面性能上的消耗。
```{r}
# 清空环境变量
 rm(list=ls())

# 封装fun1
 fun1<-function(x){
   myFUN<- function(x, c1, c2) {
     c(sum(x[c1],1), mean(x[c2])) 
   }
   apply(x,1,myFUN,c1='x1',c2=c('x1','x2'))
 }

# 封装fun2
 fun2<-function(x){
   df<-data.frame()
   for(i in 1:nrow(x)){
     row<-x[i,]
     df<-rbind(df,rbind(c(sum(row[1],1), mean(row))))
   }
 }

# 封装fun3
 fun3<-function(x){
   data.frame(x1=x[,1]+1,x2=rowMeans(x))
 }

# 生成数据集
x <- cbind(x1=3, x2 = c(400:1, 2:500))

# 分别统计3种方法的CPU耗时。
 system.time(fun1(x))
 

system.time(fun2(x))


system.time(fun3(x))
```


从CPU的耗时来看，用for循环实现的计算是耗时最长的，apply实现的循环耗时很短，而直接使用R语言内置的向量计算的操作几乎不耗时。通过上面的测试，对同一个计算来说，优先考虑R语言内置的向量计算，必须要用到循环时则使用apply函数，应该尽量避免显示的使用for,while等操作方法。

## lapply函数
lapply函数是一个最基础循环操作函数之一，用来对list、data.frame数据集进行循环，并返回和X长度同样的list结构作为结果集，通过lapply的开头的第一个字母’l’就可以判断返回结果集的类型。


函数定义：
```{r eval=FALSE}
lapply(X, FUN, ...)
```



## dplyr package



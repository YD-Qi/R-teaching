[
["index.html", "R 语言入门，给一心只有学习的你 Chapter 1 前言 1.1 R 的前世今生 1.2 R 的安装 1.3 RStudio界面", " R 语言入门，给一心只有学习的你 Chris Qi from Data Maniac 2018-09-11 Chapter 1 前言 数据是21世纪的新能源，用可靠的数据，可靠的方法，讲可靠的故事，下可靠的结论 R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。(http://blog.fens.me/r-apply/) 想直接上手的同学，可以跳过这一部分，从安装软件开始。如果软件已经安装了，可以跳到第二章。对于喜欢把书从头读到未的同学，欢迎从这里开始。 1.1 R 的前世今生 看到这个题目，你以为我会跟你絮絮叨叨讲一个软件的发展史？这种东西听一耳朵就可以了，写出来都浪费纸墨，噢，这是电子书，不用纸也不用墨，但是打字也费劲儿呀。所以在这里，我就做个大概介绍吧： R是一门用于统计计算和作图的语言，由S语言发展而来，以统计分析功能见长。 S语言由贝尔实验室1976年开发，是一个内部使用的统计分析工具。 R 是新西兰的罗斯.伊哈卡 (Ross Ihaka)和罗伯特.金特尔曼（Robert Gentleman）基于S语言开发，1993年面世。1995年采用通用公共许可协议，使之成为免费软件。 在国外高校的统计系，R几乎是一门必修的语言，具有统治性的地位。事实上，统计系的师生是R开发更新的主力。其中不少中国人的身影，例如谢益辉，编写了一系列的功能包，tnitr, rmarkdown, bookdown等等。我这本书就是在用谢益辉编写的这几个功能包写就的。 什么是R功能包？ 包就是R函数、数据、预编译代码以一种定义完善的格式组成的集合。用人话说，就是一堆有用的函数打包起来给你用。R自带了一系列默认包（包括’base、datasets、utils、grDevices、graphics、stats’等），它们提供了种类繁多的默认函数和数据集。非默认的包需要安装后调用。在R的综合档案网络CRAN中，提供了大量的第三方功能包，无所不包，包治百病。 Google首席经济学家Hal Varian说：R的最让人惊艳之处在于你可以通过修改它来做所有的事情，而你已经拥有大量可用的工具包，这无疑让你是站在巨人的肩膀上工作。 最大特点：免费，开源。免费，开源。免费，开源。说三遍！ 所以它极具生命力，每一天都有无数颗聪明的大脑在为R燃烧贡献智慧，开发更新各种包，然后免费给所有人用。 1.2 R 的安装 要愉快地使用R, 我们需要走两步： 到这个网站 CRAN（Comprehensive R Archive Network）http://www.r-project.org/ ，下载R程序。Linux、Mac OS X和Windows都有相应的版本，根据你的电脑系统，选择对应的安装包，下载安装即可。如果你找不到程序位置，那么请看这里http://ftp.ctex.org/mirrors/CRAN/ 到Rstudio官网http://www.rstudio.com/ide/download/，下载Rstudio程序，选择desktop那种，免费的就够用了。 一般来说，我们不在R里面直接操作，在安装R以后，我们在安装Rstudio，在Rstudio里完成我们所有的工作。R 与 RStudio 是什么关系呢？你可以简单的理解为，RStudio 是话筒，而 R 则是沟通所用的语言。 1.3 RStudio界面 https://www.dropbox.com/s/cy1ls5p6f4qqcya/rstudio.png?dl=0 /Users/yuandong/Dropbox/Public/rstudio.png knitr::include_graphics(rep(“images/knit-logo.png”, 3)) "],
["-r-basics-1.html", "Chapter 2 新手上路 R Basics 1 2.1 R的数学运算： 2.2 赋值 2.3 使用 ? or help() 查询 2.4 功能包 2.5 查看路径和设置路径 2.6 数据类型 2.7 数据结构 2.8 常用函数", " Chapter 2 新手上路 R Basics 1 R是一种区分大小写的解释型语言。你可以在命令提示符（&gt;）后每次输入并执行一条命令，或者一次性执行写在脚本文件中的一组命令。R中有多种数据类型，包括向量、矩阵、数据框（与数据集类似）以及列表（各种对象的集合）。 2.1 R的数学运算： 可以当作最基本的计算器来使用。 * 加: + * 减: - * 乘: 除: / * 乘方: ^ * 取余数: %% # An addition 5 + 5 ## [1] 10 # A subtraction 5 - 5 ## [1] 0 # A multiplication 3 * 5 ## [1] 15 # A division (5 + 5) / 2 ## [1] 5 # Exponentiation 2^5 ## [1] 32 # Modulo 28%%6 ## [1] 4 上面这些被称作表达式expression。 2.2 赋值 R使用&lt;-作为赋值符号。 简单说来，赋值就是给一些东西取个名字，这样以后方便叫它。 是这么操作的： my_var&lt;-42 咿呀，屏幕上没有显示任何输出？ 不用惊讶，我们刚刚只是赋值把my_var存起来了，不信看RStudio右上角的“environment”。 my_var可在稍后被显示和继续使用。 然后你只需要输入my_var，R Console就将42输出来： my_var ## [1] 42 上面我们提到了对象，对象是什么呢？ 一个对象可以是任何能被赋值的东西。对于R来说，对象可以是任何东西（数据、函数、图形、分析结果，等等），我们后面会详细讲解不同对象。 我们也可以使用c() 這個函数 function（c 意指是 combine）来赋值，它把多个对象放到一起，组成向量。 #我是注释 lucky_numbers &lt;- c(7, 77) lucky_numbers ## [1] 7 77 注释由符号#开头。在#之后出现的任何文本都会被R忽略而不运行。 2.3 使用 ? or help() 查询 输入?c 或者help(c)，在RStudio 右下角的介面 召唤出帮助文件 Help。 2.4 功能包 上面的c()是我们遇到的第一个函数，我们以后还会遇到许许多多的函数。而功能包则是函数的有机组合，以实现更丰富的功能。 R自带了一系列默认包（包括base、datasets、utils、grDevices、graphics、stats以及methods），它们提供了种类繁多的默认函数和数据集。其他包可通过下载来进行安装。安装好以后，它们必须被载入到会话中才能使用。命令search()可以告诉你哪些包已加载并可使用。 第一次安装一个包，使用命令install.packages()即可，例如： install.packages(&quot;dplyr&quot;) 一个包仅需安装一次。但和其他软件类似，包经常被其作者更新。使用命令update.packages()可以更新已经安装的包。 要在R会话中使用包，还需要使用library()命令载入这个包： library(dplyr) 当然，载入前，一定要先下载，确保有包可以调用才行。 然后我们就可以愉快的使用包了，具体来说里面的各种函数和数据。包中往往提供了演示性的小型数据集和示例代码，能够让我们尝试这些新功能。 使用 help(package=“package_name”)可以查看某个包的简短描述以及包中的函数名称和数据集名称的列表。使用函数help()可以查看其中任意函数或数据集的更多细节。 2.5 查看路径和设置路径 路径（工作路径）是我们读取数据和存贮结果的地方。 * getwd() * setwd(yourpath) * 或者使用RStudio右下方,Files这个tab里的齿轮来查看和更改。 2.6 数据类型 主要有这几种： 数值型 numerics (1, 2.5) 逻辑判断 logical (TRUE or FALSE) 字符型 characters 因子 factors # Change my_numeric to be 42 my_numeric &lt;- 42 # Change my_character to be &quot;universe&quot; my_character &lt;- &quot;universe&quot; # Change my_logical to be FALSE my_logical &lt;- FALSE # 思考：不同的类型能加减吗？ 因子 factors复杂一点，也非常有用，单独来讲一下。 如何判断数据类型？ 使用 class() 函数。 示例： # Declare variables of different types: my_numeric &lt;- 42 my_character &lt;- &quot;universe&quot; my_logical &lt;- FALSE # Check class of my_numeric class(my_numeric) ## [1] &quot;numeric&quot; # Check class of my_character class(my_character) ## [1] &quot;character&quot; # Check class of my_logical class(my_logical) ## [1] &quot;logical&quot; 2.7 数据结构 有这么几个：vector 向量、matrix 矩阵，dataframe 数据集，list 列表。 * 向量可以构成矩阵 * 矩阵是特殊的数据集 * list 是个筐，什么都能装 2.7.1 vector 向量 向量是用于存储数值型、字符型或逻辑型数据的一维数组。执行组合功能的函数c()可用来创建向量。 a &lt;- c(1, 2, 5, 3, 6, -2, 4) b &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;) c &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE) 这里，a是数值型向量，b是字符型向量，而c是逻辑型向量。 注意，单个向量中的数据必须拥有相同的类型或模式（数值型、字符型或逻辑型）。物以类聚，各从其类，同一向量中无法混杂不同模式的数据。 通过在方括号中给定元素所处位置的数值，我们可以访问向量中的元素。例如’a[c(2)]’用于访问向量a中的第二个元素。 a[c(2)] ## [1] 2 更多示例如下： b[c(1,3)] ## [1] &quot;apple&quot; &quot;orange&quot; c[c(2:4)] ## [1] FALSE TRUE FALSE 最后一个语句中使用的冒号,意思是取第二个到第三元素。 2.7.2 matrix 矩阵 矩阵是一个二维数组，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）。可通过函数matrix()创建矩阵。一般使用格式为： myymatrix &lt;- matrix(vector, nrow=number_of_rows, ncol=number_of_columns, byrow=logical_value) 其中vector包含了矩阵的元素，nrow和ncol用以指定行和列的维数，dimnames包含了可选的、以字符型向量表示的行名和列名。选项byrow则表明矩阵应当按行填充（byrow=TRUE）还是按列填充（byrow=FALSE），默认情况下按列填充。 myMatrix &lt;- matrix(1:15, nrow=3, ncol=5) myMatrix ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 4 7 10 13 ## [2,] 2 5 8 11 14 ## [3,] 3 6 9 12 15 我们可以使用下标和方括号来选择矩阵中的行、列或元素。‘r X[i,]’指矩阵X中的第i行，’r X[,j]’指第j列，’r X[i, j]’ 指第 i 行第 j 个元素。选择多行或多列时，下标 i 和 j 可为数值型向量。 y &lt;- matrix(1:18, nrow=2) y ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## [1,] 1 3 5 7 9 11 13 15 17 ## [2,] 2 4 6 8 10 12 14 16 18 y[2,] ## [1] 2 4 6 8 10 12 14 16 18 y[,1] ## [1] 1 2 y[2,c(3:5)] ## [1] 6 8 10 矩阵都是二维的，和向量类似，矩阵中也仅能包含一种数据类型。 2.7.3 dataframe 数据框 由于不同的列可以包含不同模式（数值型、字符型等）的数据，所以啊，数据框真是是个筐，什么都能装！数据框将是你在R中最常处理的数据结构。 表2-1所示的分数数据集包含了数值型和字符型数据。由于数据有多种模式，无法将此数据集放入一个矩阵。在这种情况下，使用数据框是最佳选择。 students &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) math_score&lt;-c(100, 80, 70, 95) english_score&lt;-c(96, 86, 77, 99) students_scores&lt;-data.frame(students, math_score,english_score) 划重点： * 列与列之间数据类型可以不一样，但是每一列数据类型必须一直。 * 我们在讨论数据框时将交替使用术语列和变量。 * 选取数据框中元素的方式：可以使用前述（如矩阵中的）下标记号，亦可直接指定列名，例如： students_scores[,2] ## [1] 100 80 70 95 students_scores[,&quot;math_score&quot;] ## [1] 100 80 70 95 students_scores$math_score ## [1] 100 80 70 95 第三个例子中的记号$是新出现的,它被用来选取一个给定数据框中的某个特定变量。例如，如果你想生成学生名字变量students和数学成绩变量math的新数据框，使用以下代码即可： data.frame(students_scores$students, students_scores$math_score) ## students_scores.students students_scores.math_score ## 1 A 100 ## 2 B 80 ## 3 C 70 ## 4 D 95 2.7.4 因子 factor 因子 factor又叫分类变量，有两种：名义型、有序型。 * 名义型，例如，学生的名字，它们之间是没有顺序的。 * 有序型，例如，好评，中评，差评，它们之间有顺序关系，但是没有数量关系，得不出来不同级别之间的差异具体是多少。 相对应的，像之前栗子里，分数则是一个连续性变量，呈现为某个范围内的任意值，并同时表示了顺序和数量，例如95分就是比90分要高，并且是高5分。 因子在R中非常重要，因为它决定了数据的分析方式以及如何进行视觉呈现。 函数factor()以一个整数向量的形式存储类别值，整数的取值范围是[1…k]（其中 k 是名义型变量中唯一值的个数），同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。 是不是有点晕，不着急，我们看点例子： excellence&lt;- c(&quot;excellent&quot;, &quot;bad&quot;, &quot;good&quot;, &quot;okay&quot;, &quot;bad&quot;) excellence&lt;- factor(excellence) excellence ## [1] excellent bad good okay bad ## Levels: bad excellent good okay excellence &lt;- factor(excellence, order=TRUE, levels=c(&quot;bad&quot;, &quot;okay&quot;,&quot;good&quot;,&quot;excellent&quot;)) excellence ## [1] excellent bad good okay bad ## Levels: bad &lt; okay &lt; good &lt; excellent 这里我们成功的把字符型变量excellence，先转换成了无序因子变量，再转换成了有顺序的因子变量。 数值型变量可以用levels和labels参数来编码成因子。如果男性被编码成1，女性被编码成2，则以下语句： sex&lt;-c(1,2,2,1,2,1,1,3) sex ## [1] 1 2 2 1 2 1 1 3 sex &lt;- factor(sex, levels=c(1, 2), labels=c(&quot;Male&quot;, &quot;Female&quot;)) sex ## [1] Male Female Female Male Female Male Male &lt;NA&gt; ## Levels: Male Female 在这个栗子里，性别被当成类别型变量，标签“Male”和“Female”替代了1和2在结果中输出，而且所有不是1或2的性别变量将被设为缺失值。 2.7.5 list 列表 列表（list）是R的数据类型中最为复杂的一种。一般来说，列表就是一些对象（或成分，component）的有序集合。列表允许你整合若干（可能无关的）对象到单个对象名下。例如，某个列表中可能是若干向量、矩阵、数据框，甚至其他列表的组合。可以使用函数list()创建列表： a &lt;- &quot;My First List&quot; b &lt;- c(25, 26, 18, 39) c &lt;- matrix(1:10, nrow=5) d &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) mylist &lt;- list(title=a ,b,c,d) mylist ## $title ## [1] &quot;My First List&quot; ## ## [[2]] ## [1] 25 26 18 39 ## ## [[3]] ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 ## ## [[4]] ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; 本例创建了一个列表，其中有四个成分：一个字符串、一个数值型向量、一个矩阵以及一个字符型向量。可以组合任意多的对象，并将它们保存为一个列表。 2.8 常用函数 length(object) ：显示对象中元素/成分的数量 length(mtcars) ## [1] 11 length(mtcars$mpg) ## [1] 32 dim(object)： 显示某个对象的维度 dim(mtcars) ## [1] 32 11 str(object) ：显示某个对象的结构 str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... class(object)： 显示某个对象的类或类型 class(mtcars) ## [1] &quot;data.frame&quot; names(object)：显示某对象中各成分的名称 names(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; c(object, object,…)： 将对象合并入一个向量 c(2, 20) ## [1] 2 20 cbind(object, object, …)： 按列合并对象 cbind(students, math_score) ## students math_score ## [1,] &quot;A&quot; &quot;100&quot; ## [2,] &quot;B&quot; &quot;80&quot; ## [3,] &quot;C&quot; &quot;70&quot; ## [4,] &quot;D&quot; &quot;95&quot; rbind(object, object, …)： 按行合并对象 rbind(students, math_score) ## [,1] [,2] [,3] [,4] ## students &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ## math_score &quot;100&quot; &quot;80&quot; &quot;70&quot; &quot;95&quot; head(object)：列出某个对象的开始部分 head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 tail(object)：列出某个对象的最后部分 tail(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 ls()： 显示当前的对象列表 ls() ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [4] &quot;d&quot; &quot;english_score&quot; &quot;excellence&quot; ## [7] &quot;lucky_numbers&quot; &quot;math_score&quot; &quot;my_character&quot; ## [10] &quot;my_logical&quot; &quot;my_numeric&quot; &quot;my_var&quot; ## [13] &quot;mylist&quot; &quot;myMatrix&quot; &quot;sex&quot; ## [16] &quot;students&quot; &quot;students_scores&quot; &quot;y&quot; rm(object, object, …)： 删除一个或更多个对象。 rm(a, b, c) ls() ## [1] &quot;d&quot; &quot;english_score&quot; &quot;excellence&quot; ## [4] &quot;lucky_numbers&quot; &quot;math_score&quot; &quot;my_character&quot; ## [7] &quot;my_logical&quot; &quot;my_numeric&quot; &quot;my_var&quot; ## [10] &quot;mylist&quot; &quot;myMatrix&quot; &quot;sex&quot; ## [13] &quot;students&quot; &quot;students_scores&quot; &quot;y&quot; rm(list = ls())：将删除当前工作环境中的几乎所有对象4 "],
["-r-basics-2.html", "Chapter 3 新手上路 R Basics 2 3.1 为什么要学统计？ 3.2 补一点统计知识 3.3 基本作图", " Chapter 3 新手上路 R Basics 2 3.1 为什么要学统计？ 不管你是谁，不得不承认，我们所生活的世界，复杂，多变，充满随机性与不确定性。 同时，在这纷繁复杂的表象里面，也蕴含着必然的规律，也可以说是“套路”。 发现这些规律，帮助我们更好的理解我们的世界，作出更正确的决定，做更好的自己，哦耶。 这正是统计学干的事情。 不，我们借统计学干的事情。 []!(/Users/yuandong/Dropbox/Public/stats.png) 幸存者偏差，二战盟军统计学家沃尔德 老物件、双盲实验、成功者的故事（从大学退学的特征） 不能只看贼吃肉，不看贼挨揍 3.2 补一点统计知识 描述性统计：Summary statistics 3.2.1 集中趋势统计量: 均值（Mean)、中位数(Median)、众数(Mode)、百分位数(percentile) 均值（Mean): 描述数据取值的平均位置，指一组数据的平均数 mean(mtcars$mpg) ## [1] 20.09062 中位数(Median): 定义为数据排序位于中间位置的值 median(mtcars$mpg) ## [1] 19.2 *众数(Mode): 就是一组数据中占比例最多的那个数， R中未提供直接调用的函数 names(table(mtcars$mpg))[which.max(table(mtcars$mpg))] ## [1] &quot;10.4&quot; *百分位数 (percentile) quantile(mtcars$mpg) ## 0% 25% 50% 75% 100% ## 10.400 15.425 19.200 22.800 33.900 3.2.2 离散趋势统计量：方差（var)、极差（range) 方差（Variance): 是描述数据取值分散性的一个度量.样本方差(sample variance)是样本相对于均值的偏差平方和的平均,记为s2: \\[s2=\\frac{1}{n-1}\\sum ^n _{i=1} (x_i-\\bar{x})^2\\] * 标准差就是方差开方： \\[s=\\sqrt{\\frac{1}{n-1}\\sum ^n _{i=1} (x_i-\\bar{x})^2}\\] var(mtcars$mpg) ## [1] 36.3241 极差（Range): 描述样本分散性的数字特征.当数据越分散,其极差越大 range(mtcars$mpg) ## [1] 10.4 33.9 summary(mtcars$mpg) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 10.40 15.43 19.20 20.09 22.80 33.90 summary(mtcars) ## mpg cyl disp hp ## Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 ## 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 ## Median :19.20 Median :6.000 Median :196.3 Median :123.0 ## Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 ## 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 ## Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 ## drat wt qsec vs ## Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 ## 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 ## Median :3.695 Median :3.325 Median :17.71 Median :0.0000 ## Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 ## 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 ## Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 ## am gear carb ## Min. :0.0000 Min. :3.000 Min. :1.000 ## 1st Qu.:0.0000 1st Qu.:3.000 1st Qu.:2.000 ## Median :0.0000 Median :4.000 Median :2.000 ## Mean :0.4062 Mean :3.688 Mean :2.812 ## 3rd Qu.:1.0000 3rd Qu.:4.000 3rd Qu.:4.000 ## Max. :1.0000 Max. :5.000 Max. :8.000 3.3 基本作图 一图胜千言 人类非常善于从视觉呈现中洞察关系。一幅精心绘制的图形能够帮助你在数以千计的零散信 息中做出有意义的比较，提炼出使用其他方法时不那么容易发现的模式。这也是统计图形领域的 进展能够对数据分析产生重大影响的原因之一。数据分析师需要观察他们的数据，而R在该领域 表现出众。（Actions in R） R是一个惊艳的图形构建平台。在通常的交互式会话中，我们可 以通过逐条输入语句构建图形，逐渐完善图形特征，直至得到想要的效果。 plot()是R中为对象作图的一个泛型函数(它的输出将根据所绘制对象类型的不同而变化)。 plot(x, y, type=&quot;b&quot;) 将x置于横轴，将y置于纵轴，绘制点集(x, y)，散点图。使用help(plot)可以查看其他选项。 plot(mtcars$wt, mtcars$mpg) abline(lm(mtcars$mpg~mtcars$wt)) title(&quot;Regression of MPG on Weight&quot;) plot(mtcars$wt, mtcars$mpg, xlab=&quot;Miles Per Gallon&quot;, ylab=&quot;Car Weight&quot;) abline(lm(mtcars$mpg~mtcars$wt)) title(&quot;Regression of MPG on Weight&quot;) 第一条语句打开了一个图形窗口并生成了一幅散点图，横轴表 示车身重量，纵轴为每加仑汽油行驶的英里数。第二句向图形添加了一条最优拟合曲线。第三句 添加了标题。 plot(mtcars$wt, mtcars$mpg, xlab=&quot;Miles Per Gallon&quot;, ylab=&quot;Car Weight&quot;, col=4) abline(lm(mtcars$mpg~mtcars$wt)) title(&quot;Regression of MPG on Weight&quot;) plot(mtcars$wt, mtcars$mpg, xlab=&quot;Miles Per Gallon&quot;, ylab=&quot;Car Weight&quot;, col=4, pch=16) abline(lm(mtcars$mpg~mtcars$wt)) title(&quot;Regression of MPG on Weight&quot;) 总是用美元符号，是不是太麻烦？换一种方式： with(mtcars,{ plot(wt, mpg) abline(lm(mpg~wt)) title(&quot;Regression of MPG on Weight&quot;) } ) 全局参数设定，多图同列, 例如设置2列2行： par(mfrow=c(3,1)) 四个直方图： with(mtcars,{ par(mfrow=c(2,2)) hist(wt) hist(mpg) hist(disp) hist(hp) }) 箱图 boxplot(mtcars$mpg) 可以通过代码或图形用户界面来保存图形。 要通过代码保存图形，将绘图语句夹在开启目标 图形设备的语句和关闭目标图形设备的语句之间即可。例如，以下代码会将图形保存到当前工作 目录中名为mygraph.pdf的PDF文件中(R in Action): pdf(&quot;mygraph.pdf&quot;) attach(mtcars) plot(wt, mpg) abline(lm(mpg~wt)) title(&quot;Regression of MPG on Weight&quot;) detach(mtcars) dev.off() ## quartz_off_screen ## 2 除了pdf()，还可以使用函数win.metafile()、png()、jpeg()、bmp()等将图形保存为其他格式。 通过图形用户界面保存图形，在RStudio的右下角，“Export”即可。 "],
["section-4.html", "Chapter 4 数据管理 4.1 添加变量 4.2 缺失值处理 4.3 导入输入 4.4 脚本", " Chapter 4 数据管理 4.1 添加变量 4.2 缺失值处理 4.3 导入输入 4.4 脚本 "],
["rapply.html", "Chapter 5 掌握R语言中的apply函数族 5.1 apply的家族函数 5.2 apply函数 5.3 lapply函数 5.4 dplyr package", " Chapter 5 掌握R语言中的apply函数族 http://blog.fens.me/r-apply/ 刚开始接触R语言时，会听到各种的R语言使用技巧，其中最重要的一条就是不要用循环，效率特别低，要用向量计算代替循环计算。 那么，这是为什么呢？原因在于R的循环操作for和while，都是基于R语言本身来实现的，而向量操作是基于底层的C语言函数实现的，从性能上来看，就会有比较明显的差距了。那么如何使用C的函数来实现向量计算呢，就是要用到apply的家族函数，包括apply, sapply, tapply, mapply, lapply, rapply, vapply, eapply等。 5.1 apply的家族函数 apply函数族是R语言中数据处理的一组核心函数，通过使用apply函数，我们可以实现对数据的循环、分组、过滤、类型控制等操作。但是，由于在R语言中apply函数与其他语言循环体的处理思路是完全不一样的，所以apply函数族一直是使用者玩不转一类核心函数。 很多R语言新手，写了很多的for循环代码，也不愿意多花点时间把apply函数的使用方法了解清楚，最后把R代码写的跟C似得，我严重鄙视只会写for的R程序员。 apply函数本身就是解决数据循环处理的问题，为了面向不同的数据类型，不同的返回值，apply函数组成了一个函数族，包括了8个功能类似的函数。这其中有些函数很相似，有些也不是太一样的。 最常用的函数为apply和sapply，下面将分别介绍这8个函数的定义和使用方法。 5.2 apply函数 apply函数是最常用的代替for循环的函数。apply函数可以对矩阵、数据框、数组(二维、多维)，按行或列进行循环计算，对子元素进行迭代，并把子元素以参数传递的形式给自定义的FUN函数中，并以返回计算结果。 函数定义： apply(X, MARGIN, FUN, ...) 参数列表： X:数组、矩阵、数据框 MARGIN: 按行计算或按按列计算，1表示按行，2表示按列 FUN: 自定义的调用函数 …: 更多参数，可选 比如，对一个矩阵的每一行求和，下面就要用到apply做循环了。 x&lt;-matrix(1:12,ncol=3) apply(x,1,sum) ## [1] 15 18 21 24 下面计算一个稍微复杂点的例子，按行循环，让数据框的x1列加1，并计算出x1,x2列的均值。 生成data.frame x &lt;- cbind(x1 = 3, x2 = c(4:1, 2:5)) x ## x1 x2 ## [1,] 3 4 ## [2,] 3 3 ## [3,] 3 2 ## [4,] 3 1 ## [5,] 3 2 ## [6,] 3 3 ## [7,] 3 4 ## [8,] 3 5 # 自定义函数myFUN，第一个参数x为数据 # 第二、三个参数为自定义参数，可以通过apply的&#39;...&#39;进行传入。 myFUN&lt;- function(x, c1, c2) { c(sum(x[c1],1), mean(x[c2])) } # 把数据框按行做循环，每行分别传递给myFUN函数，设置c1,c2对应myFUN的第二、三个参数 apply(x,1,myFUN,c1=&#39;x1&#39;,c2=c(&#39;x1&#39;,&#39;x2&#39;)) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 4.0 4 4.0 4 4.0 4 4.0 4 ## [2,] 3.5 3 2.5 2 2.5 3 3.5 4 通过这个上面的自定义函数myFUN就实现了，一个常用的循环计算。 如果直接用for循环来实现，那么代码如下： # 定义一个结果的数据框 df&lt;-data.frame() # 定义for循环 for(i in 1:nrow(x)){ row&lt;-x[i,] # 每行的值 df&lt;-rbind(df,rbind(c(sum(row[1],1), mean(row)))) #计算，并赋值到结果数据框 } # 打印结果数据框 df 通过for循环的方式，也可以很容易的实现上面计算过程，但是这里还有一些额外的操作需要自己处理，比如构建循环体、定义结果数据集、并合每次循环的结果到结果数据集。 对于上面的需求，还有第三种实现方法，那就是完成利用了R的特性，通过向量化计算来完成的。 data.frame(x1=x[,1] 1,x2=rowMeans(x)) 那么，一行就可以完成整个计算过程了。 接下来，我们需要再比较一下3种操作上面性能上的消耗。 # 清空环境变量 rm(list=ls()) # 封装fun1 fun1&lt;-function(x){ myFUN&lt;- function(x, c1, c2) { c(sum(x[c1],1), mean(x[c2])) } apply(x,1,myFUN,c1=&#39;x1&#39;,c2=c(&#39;x1&#39;,&#39;x2&#39;)) } # 封装fun2 fun2&lt;-function(x){ df&lt;-data.frame() for(i in 1:nrow(x)){ row&lt;-x[i,] df&lt;-rbind(df,rbind(c(sum(row[1],1), mean(row)))) } } # 封装fun3 fun3&lt;-function(x){ data.frame(x1=x[,1]+1,x2=rowMeans(x)) } # 生成数据集 x &lt;- cbind(x1=3, x2 = c(400:1, 2:500)) # 分别统计3种方法的CPU耗时。 system.time(fun1(x)) ## user system elapsed ## 0.008 0.000 0.007 system.time(fun2(x)) ## user system elapsed ## 0.175 0.009 0.187 system.time(fun3(x)) ## user system elapsed ## 0.001 0.000 0.002 从CPU的耗时来看，用for循环实现的计算是耗时最长的，apply实现的循环耗时很短，而直接使用R语言内置的向量计算的操作几乎不耗时。通过上面的测试，对同一个计算来说，优先考虑R语言内置的向量计算，必须要用到循环时则使用apply函数，应该尽量避免显示的使用for,while等操作方法。 5.3 lapply函数 lapply函数是一个最基础循环操作函数之一，用来对list、data.frame数据集进行循环，并返回和X长度同样的list结构作为结果集，通过lapply的开头的第一个字母’l’就可以判断返回结果集的类型。 函数定义： lapply(X, FUN, ...) 5.4 dplyr package "],
["r-base-graphics-in-r.html", "Chapter 6 R 基础作图快速入门 base graphics in R", " Chapter 6 R 基础作图快速入门 base graphics in R 导语：用数据说话的今天，随着数据量的不断增加，数据可视化成为将数字变成可用的信息的一个重要方式。 Base graphics: 最容易上手, 同时也非常有用的绘图技巧, 是这一节课的主要内容。 Grid graphics: 开发其它作图工具的强大工具 Lattice graphics: 基于 grid graphics的一般作图系统 ggplot2: 有语法，用写作的方式作图，非常炫酷，可视化必备 Base graphics: library(MASS) plot(UScereal$sugars, UScereal$Calories) title(&quot;plot(UScereal$sugars, UScereal$calories)&quot;) Grid graphics，非人类的语言，不适用于一般的数据可视化: # Get the data and load the grid package library(MASS) x &lt;- UScereal$sugars y &lt;- UScereal$calories library(grid) # This is the grid code required to generate the plot pushViewport(plotViewport()) pushViewport(dataViewport(x, y)) grid.rect() grid.xaxis() grid.yaxis() grid.points(x, y) grid.text(&quot;UScereal$calories&quot;, x = unit(-3, &quot;lines&quot;), rot = 90) grid.text(&quot;UScereal$sugars&quot;, y = unit(-3, &quot;lines&quot;), rot = 0) popViewport(2) Lattice graphics: library(MASS) library(lattice) xyplot(MPG.city ~ Horsepower | Cylinders, data = Cars93) ggplot2: library(MASS) library(ggplot2) title &lt;- &quot;ggplot2 plot of \\n UScereal$calories vs. \\n UScereal$sugars&quot; basePlot &lt;- ggplot(UScereal, aes(x = sugars, y = calories)) basePlot + geom_point(shape = as.character(UScereal$shelf), size = 3) + annotate(&quot;text&quot;, label = title, x = 3, y = 400, colour = &quot;red&quot;) 探索性数据可视化: 帮助你看一看数据里都有什么，注意尽量多地保留细节，便于进一步分析 探索小鸡的成长之路：ChickWeight数据集 plot(ChickWeight) 解释性数据可视化：让别人明白数据，便于交流信息，呈现你的数据发现 请在下面的练习开始前，下载并安装下面这些包： install.packages(&quot;insuranceData&quot;) install.packages(&quot;MASS&quot;) install.packages(&quot;robustbase&quot;) install.packages(&quot;car&quot;) install.packages(&quot;aplpack&quot;) install.packages(&quot;corrplot&quot;) install.packages(&quot;rpart&quot;) # Load MASS package library(dplyr) ## Warning: package &#39;dplyr&#39; was built under R version 3.5.1 ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:MASS&#39;: ## ## select ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(MASS) library(robustbase) library(insuranceData) library(car) ## Loading required package: carData ## ## Attaching package: &#39;car&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## recode 我们用一个简单的冬季取暖数据来建构一个简单的分析图： Temp: 一周的室外气温 Gas: 该周的天然气用量 Insul: 有两个值的分类变量，分别代表房子升级改造前后 简单绘图看一下： # Plot whiteside data plot(whiteside) 简单的探索性散点图： 不要完全依赖默认设置，适当修改，让图更有意义容易理解 做一个气温与天然气用量的散点图，加上轴标签： plot(whiteside$Temp,whiteside$Gas, xlab=&quot;Outside temperature&quot;, ylab= &quot;Heating gas consumption&quot;) plot()是一个一般性的函数，会根据数据类型的不同而作出不同的图，例如下面，我们把它用在whiteside$Insul上，得到一个完全不一样的图 plot(whiteside$Insul) 使用形状，颜色和参考线来增加细节，我们用Cars93这个数据集来做一个高级一点的图来展示三个变量间的关系： Price: 某款车的平均售价 Max.Price: 该款车的最高售价 Min.Price: 该款车的最低售价 使用 glimpse() 来看看这个Cars93 都有什么变量 glimpse(Cars93) ## Observations: 93 ## Variables: 27 ## $ Manufacturer &lt;fct&gt; Acura, Acura, Audi, Audi, BMW, Buick, Buick... ## $ Model &lt;fct&gt; Integra, Legend, 90, 100, 535i, Century, Le... ## $ Type &lt;fct&gt; Small, Midsize, Compact, Midsize, Midsize, ... ## $ Min.Price &lt;dbl&gt; 12.9, 29.2, 25.9, 30.8, 23.7, 14.2, 19.9, 2... ## $ Price &lt;dbl&gt; 15.9, 33.9, 29.1, 37.7, 30.0, 15.7, 20.8, 2... ## $ Max.Price &lt;dbl&gt; 18.8, 38.7, 32.3, 44.6, 36.2, 17.3, 21.7, 2... ## $ MPG.city &lt;int&gt; 25, 18, 20, 19, 22, 22, 19, 16, 19, 16, 16,... ## $ MPG.highway &lt;int&gt; 31, 25, 26, 26, 30, 31, 28, 25, 27, 25, 25,... ## $ AirBags &lt;fct&gt; None, Driver &amp; Passenger, Driver only, Driv... ## $ DriveTrain &lt;fct&gt; Front, Front, Front, Front, Rear, Front, Fr... ## $ Cylinders &lt;fct&gt; 4, 6, 6, 6, 4, 4, 6, 6, 6, 8, 8, 4, 4, 6, 4... ## $ EngineSize &lt;dbl&gt; 1.8, 3.2, 2.8, 2.8, 3.5, 2.2, 3.8, 5.7, 3.8... ## $ Horsepower &lt;int&gt; 140, 200, 172, 172, 208, 110, 170, 180, 170... ## $ RPM &lt;int&gt; 6300, 5500, 5500, 5500, 5700, 5200, 4800, 4... ## $ Rev.per.mile &lt;int&gt; 2890, 2335, 2280, 2535, 2545, 2565, 1570, 1... ## $ Man.trans.avail &lt;fct&gt; Yes, Yes, Yes, Yes, Yes, No, No, No, No, No... ## $ Fuel.tank.capacity &lt;dbl&gt; 13.2, 18.0, 16.9, 21.1, 21.1, 16.4, 18.0, 2... ## $ Passengers &lt;int&gt; 5, 5, 5, 6, 4, 6, 6, 6, 5, 6, 5, 5, 5, 4, 6... ## $ Length &lt;int&gt; 177, 195, 180, 193, 186, 189, 200, 216, 198... ## $ Wheelbase &lt;int&gt; 102, 115, 102, 106, 109, 105, 111, 116, 108... ## $ Width &lt;int&gt; 68, 71, 67, 70, 69, 69, 74, 78, 73, 73, 74,... ## $ Turn.circle &lt;int&gt; 37, 38, 37, 37, 39, 41, 42, 45, 41, 43, 44,... ## $ Rear.seat.room &lt;dbl&gt; 26.5, 30.0, 28.0, 31.0, 27.0, 28.0, 30.5, 3... ## $ Luggage.room &lt;int&gt; 11, 15, 14, 17, 13, 16, 17, 21, 14, 18, 14,... ## $ Weight &lt;int&gt; 2705, 3560, 3375, 3405, 3640, 2880, 3470, 4... ## $ Origin &lt;fct&gt; non-USA, non-USA, non-USA, non-USA, non-USA... ## $ Make &lt;fct&gt; Acura Integra, Acura Legend, Audi 90, Audi ... 最高价vs.平均价，红色三角 plot(Cars93$Max.Price, Cars93$Price,col=&quot;red&quot;,pch=17) 添加最高价vs. 平均价，蓝色，圆点 plot(Cars93$Max.Price, Cars93$Price,col=&quot;red&quot;,pch=17) points(Cars93$Min.Price,Cars93$Price,col=&quot;blue&quot;,pch=16) 添加一条参考线，0为截距，1为斜率，虚线 plot(Cars93$Max.Price, Cars93$Price,col=&quot;red&quot;,pch=17) points(Cars93$Min.Price,Cars93$Price,col=&quot;blue&quot;,pch=16) abline(a = 0, b = 1, lty = 2) 直方图（频率图与频数图） truehist()频率直方图的函数，来自MASS这个包： # Set up a side-by-side plot array par(mfrow=c(1,2)) # Create a histogram of counts with hist() hist(Cars93$Horsepower,main=&quot;hist() plot&quot;) # Create a normalized histogram with truehist() truehist(Cars93$Horsepower,main=&quot;hist() plot&quot;) 还记得前面的鸡吗？我们来做个直方图，频率的，加一条密度曲线。 # Create index16, pointing to 16-week chicks index16 &lt;- which(ChickWeight$Time == 16) # Get the 16-week chick weights weights &lt;- ChickWeight$weight[index16] # Plot the normalized histogram truehist(weights) # Add the density curve to the histogram lines(density(weights)) 使用par()在一个面板上画出多幅图并可修改细节： par(&quot;bg&quot;) #背景颜色，默认白色 ## [1] &quot;white&quot; par(&quot;col&quot;) # 作图颜色，默认黑色 ## [1] &quot;black&quot; par(&quot;mar&quot;) #(bottom, left, top, right) 图片边距 ## [1] 5.1 4.1 4.1 2.1 par(&quot;mfrow&quot;) #默认一行一列 ## [1] 1 1 ?par #通过改变全局参数，使面板中呈现多幅图片 par(mfrow = c(2,2)) #设置成2行两列 hist(airquality$Temp) hist(airquality$Temp, freq = FALSE) hist(airquality$Temp, freq = FALSE, col=&quot;blue&quot;) hist(airquality$Temp, freq = FALSE, col=&quot;blue&quot;) lines(density(airquality$Temp)) par(mfrow = c(1,1)) truehist(airquality$Temp) lines(density(airquality$Temp)) 散点图中的菊花图，让你更懂数据 # Set up a side-by-side plot array par(mfrow=c(1,2)) # Create the standard scatterplot plot(rad~zn,data=Boston) # Add the title title(&quot;Standard scatterplot&quot;) # Create the sunflowerplot sunflowerplot(rad~zn,data=Boston) # Add the title title(&quot;Sunflower plot&quot;) #按月份，给每一个月的温度绘箱图 #month是分类变量 boxplot(Temp~Month,airquality,xlab=&quot;month&quot;, ylab=&quot;Temperature (F)&quot;) #with() 更简便的绘图函数， # 再不用每个变量都引用数据集 with(airquality, plot(Wind~Temp)) title(main=&quot;wind and temp in NYC&quot;) #使用title进行修饰 #另外一种方式添加标题，一样的结果 with(airquality, plot(Wind, Temp, main=&quot;wind and temp in NYC&quot;)) #有用的 type=&quot;n&quot; with(airquality, plot(Wind, Temp, main=&quot;Wind and Temp in NYC&quot;, type=&quot;n&quot;)) with(airquality, plot(Wind, Temp, main=&quot;Wind and Temp in NYC&quot;, type=&quot;n&quot;)) with(subset(airquality, Month==9), points(Wind, Temp, col=&quot;red&quot;)) with(airquality, plot(Wind, Temp, main=&quot;Wind and Temp in NYC&quot;, type=&quot;n&quot;)) with(subset(airquality, Month==9), points(Wind, Temp, col=&quot;red&quot;)) with(subset(airquality, Month==8), points(Wind, Temp, col=&quot;blue&quot;)) with(airquality, plot(Wind, Temp, main=&quot;Wind and Temp in NYC&quot;, type=&quot;n&quot;)) with(subset(airquality, Month==9), points(Wind, Temp, col=&quot;red&quot;)) with(subset(airquality, Month==8), points(Wind, Temp, col=&quot;blue&quot;)) with(subset(airquality, Month==7), points(Wind, Temp, col=&quot;green&quot;)) #完成了用不同的颜色表示不同的月份的点 with(airquality, plot(Wind, Temp, main=&quot;Wind and Temp in NYC&quot;, type=&quot;n&quot;)) with(subset(airquality, Month==9), points(Wind, Temp, col=&quot;red&quot;)) with(subset(airquality, Month==8), points(Wind, Temp, col=&quot;blue&quot;)) with(subset(airquality, Month==7), points(Wind, Temp, col=&quot;green&quot;)) with(subset(airquality, Month %in% c(5,6)), points(Wind, Temp, col=&quot;black&quot;)) with(airquality, plot(Wind, Temp, main=&quot;Wind and Temp in NYC&quot;, type=&quot;n&quot;)) with(subset(airquality, Month==9), points(Wind, Temp, col=&quot;red&quot;)) with(subset(airquality, Month==8), points(Wind, Temp, col=&quot;blue&quot;)) with(subset(airquality, Month==7), points(Wind, Temp, col=&quot;green&quot;)) with(subset(airquality, Month %in% c(5,6)), points(Wind, Temp, col=&quot;black&quot;)) fit&lt;-lm(Temp~Wind, airquality) #拟合一个回归模型 abline(fit,lwd=2) #把回归线加进去 #加入图例，说明颜色含义 legend(&quot;topright&quot;, pch=1, #右上角，空心圆点 col=c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;), legend=c(&quot;Sep&quot;,&quot;August&quot;,&quot;July&quot;,&quot;Other&quot;)) #使用基本函数绘图，需要事先计划，运行很多函数， #可以直观的反映我们绘图的逻辑 #图例要仔细一一对应 lattice 绘图实践 library(lattice) #需要先安装install.packages(&quot;lattice&quot;) xyplot(Temp~Ozone, data=airquality) #散点图,还没有考察交互关系 airquality$Month&lt;-factor(airquality$Month) 使用 #查看不同月份下，前面两个变量的关系 xyplot(Temp~Ozone|Month, data=airquality, layout=c(5,1)) #画1行5列 绘制表示相关性的椭圆图 越椭圆相关性越高，高到变成一条线。越接近圆相关性越低，直到标准圆。颜色越深相关性越大，最大是1,最小的是0（绝对值），蓝色为正相关，红色为负相关。 # Load the corrplot library for the corrplot() function library(corrplot) ## corrplot 0.84 loaded # Extract the numerical variables from UScereal numericalVars &lt;- UScereal[, 2:10] # Compute the correlation matrix for these variables corrMat &lt;- cor(numericalVars) # Generate the correlation ellipse plot corrplot(corrMat, method = &quot;ellipse&quot;) 主要来自data visulization in datacamp的第一章第二章（共四章）以及慕课网的数据可视化课程。还可以继续补充。 "],
["section-7.html", "Chapter 7 数据可视化第二课： 7.1 ggplot2 绘图包介绍 7.2 用几何函数指定图形类型 7.3 分组 7.4 刻面 7.5 添加光滑曲线 7.6 保存图", " Chapter 7 数据可视化第二课： 7.1 ggplot2 绘图包介绍 7.2 用几何函数指定图形类型 7.3 分组 7.4 刻面 7.5 添加光滑曲线 7.6 保存图 "],
["section-8.html", "Chapter 8 数据可视化第三课：案例 8.1 泰坦尼克号生还者分析", " Chapter 8 数据可视化第三课：案例 8.1 泰坦尼克号生还者分析 "],
["section-9.html", "Chapter 9 线性回归第一课 9.1 相关性 9.2 回归模型", " Chapter 9 线性回归第一课 9.1 相关性 9.1.1 散点图 9.1.2 相关系数 9.1.3 线性关系 9.2 回归模型 9.2.1 模型理解 9.2.2 模型推导 9.2.3 系数含义 "],
["section-10.html", "Chapter 10 回归分析第二课 10.1 如何用R做线性回归 10.2 线性回归结果的理解", " Chapter 10 回归分析第二课 10.1 如何用R做线性回归 10.1.1 数据导入 10.1.2 前期清理 10.1.3 基本观察 10.1.4 建立模型 10.2 线性回归结果的理解 10.2.1 系数 10.2.2 R 方 10.2.3 显著度 10.2.4 模型评估 "],
["section-11.html", "Chapter 11 回归分析第三课 11.1 大学教授收入分析 11.2 广告投入与销售额分析", " Chapter 11 回归分析第三课 案例 11.1 大学教授收入分析 11.2 广告投入与销售额分析 "],
["dplyr.html", "Chapter 12 dplyr包", " Chapter 12 dplyr包 "]
]

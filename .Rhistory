skip()
boxplot(Ozone~Month, airquality, xlab="Month", ylab="Ozone (ppb)",col.axis="blue",col.lab="red",main="Ozone and Wind in New York City")
"Ozone and Wind in New York City"
title(main="Ozone and Wind in New York City")
with(airquality, plot(Wind~Ozone))
with(airquality, plot(Wind, Ozone))
main="Ozone and Wind in New York City"
skip()
length(par())
names(par())
par()$pin
swirl()
skip()
qgplot(diamond,price,cut)
install.packages("gdata”)
）
p <- xyplot(y ~ x | f, panel = function(x, y, ...) {
panel.xyplot(x, y, ...)  ## First call the default panel function for 'xyplot'
panel.abline(h = median(y), lty = 2)  ## Add a horizontal line at the median
})
print(p)
invisible()
clearPushBack()
library(AppliedPredictiveModeling)
data(FuelEconomy)
cars2010 <- cars2010[order(cars2010$EngDispl),]
cars2011 <- cars2011[order(cars2011$EngDispl),]
cars2010a <- cars2010
cars2010a$Year <- "2010 Model Year"
cars2011a <- cars2011
cars2011a$Year <- "2011 Model Year"
View(cars2010)
View(cars2010a)
plotData <- rbind(cars2010a, cars2011a)
library(lattice)
xyplot(FE ~ EngDispl|Year, plotData,
xlab = "Engine Displacement",
ylab = "Fuel Efficiency (MPG)",
between = list(x = 1.2))
library(caret)
set.seed(1)
lm1Fit <- train(FE ~ EngDispl,
data = cars2010,
method = "lm",
trControl = trainControl(method= "cv"))
lm1Fit
library(ggplot2)
dataset<-matrix(ncol=3,nrow=12)
colnames(dataset)<-c("Score","Action","Bin")
dataset[1:9,1]<-c(1,2,3,-2,7,10,12,3,4)
dataset[1:9,2]<-rep(1,9)
dataset[10:12,1]<-c(-1,-2,-3)
dataset[10:12,2]<-rep(2,3)
dataset[1:12,3]<-as.character(cut(dataset[1:12,1:1],breaks=4))
myDataset<-as.data.frame(dataset)
chosenbreaks<-as.vector(unique(dataset[1:12,3]))
chosenlabels<-as.vector(c(chosenbreaks[1],"","",chosenbreaks[4]))
fullplot<-ggplot(myDataset, aes(Bin, fill=Action))
+ geom_bar(position="stack")
+ opts(axis.text.x = theme_text(angle = 45,size=8))
+ scale_x_discrete("test",breaks=chosenbreaks,labels=chosenlabels)
fullplot
update.packages()
dataset[1:9,1]<-c(1,2,3,-2,7,10,12,3,4)
dataset[1:9,2]<-rep(1,9)
dataset[10:12,1]<-c(-1,-2,-3)
dataset[10:12,2]<-rep(2,3)
dataset[1:12,3]<-as.character(cut(dataset[1:12,1:1],breaks=4))
myDataset<-as.data.frame(dataset)
chosenbreaks<-as.vector(unique(dataset[1:12,3]))
chosenlabels<-as.vector(c(chosenbreaks[1],"","",chosenbreaks[4]))
fullplot<-ggplot(myDataset, aes(Bin, fill=Action))
+ geom_bar(position="stack")
+ opts(axis.text.x = theme_text(angle = 45,size=8))
+ scale_x_discrete("test",breaks=chosenbreaks,labels=chosenlabels)
fullplot
library(lattice)
xyplot(FE ~ EngDispl|Year, plotData,
xlab = "Engine Displacement",
ylab = "Fuel Efficiency (MPG)",
between = list(x = 1.2))
library(ggplot2)
qplot(mpg, wt, data=mtcars)
?read
??read
x<-1:10
y<-x+rnorm(10,0,1)
lm(y~x)
fit<-lm(y~x)
summary(fit)
linearMod <- lm(dist ~ speed, data=cars)  # build linear regression model on full data
print(linearMod)
scatter.smooth(x=cars$speed, y=cars$dist, main="Dist ~ Speed")
x <− rnorm (100 ,mean = 5 ,sd = 0 . 1 )
mean( x )
3 sd ( x )
summary( x )
x <- rnorm(100,mean = 5,sd = 0.1)
mean(x)
sd(x)
summary(x)
demo( graphics )
demo(graphics)
file.choose()
file.choose()
file.choose()
library(RColorBrewer)
col<-brewer.pal(3,'Set1')[1]
t<-seq(0,60,len=100)
x<- -.01*(-t^2+40*t+1200)*sin(pi*t/180)
y<- .01*(-t^2+40*t+1200)*cos(pi*t/180)
pdf('hearts.pdf',wid=4,hei=3)
par(mar=c(0,0,0,0))
plot(c(-12,14),c(0,20),type='n',axes=T,xlab='',ylab='')
arrows(-11,8,14,8,lwd=10,col='gold')
arrows(14,8,-11,8,lwd=10,col='gold',angle=120)
arrows(14,8,-10,8,lwd=10,col='gold',angle=120)
arrows(14,8,-9,8,lwd=10,col='gold',angle=120)
polygon(x,y,col=col,border=NA)
polygon(-x,y,col=col,border=NA)
lines(x,y,lwd=2)
lines(-x,y,lwd=2)
polygon(x+3,col=col,border=NA)
polygon(-x+3,col=col,border=NA)
lines(x+3,y,lwd=2)
lines(-x+3,y,lwd=2)
arrows(5,8,14,8,lwd=10,col='gold')
text(1,18,"I LOVE U",col='red',cex=2)
dev.off()
summary(mtcars)
summary(mtcars)
summary(mtcars)
data("mtcars")
efficient<-subset(mtcars,mpg>=23)
efficient<-subset(mtcars,mpg>=23)
data("mtcars")
efficient<-subset(mtcars,mpg>=23)
dim(efficient)
subset(mtcars, mpg > 30 & hp > 100)
subset(mtcars, mpg < 14 | disp > 390)
subset(mtcars,qsec<=16.90)
names(mtcars)
lightCars<-subset(mtcars,wt<2000)
mtcars$year <- 1974
View(mtcars)
View(mtcars)
mtcars <- subset(mtcars, select = -year)
View(efficient)
View(efficient)
View(mtcars)
View(mtcars)
mtcars$year <- c(1973, 1974)
View(mtcars)
View(mtcars)
mtcars<-subset(mtcars,select=-year)
mtcars$weight_class
mtcars$wt
cond <- mtcars$wt < 3
cond
mtcars$weight_class <- ifelse(cond, 'light', 'average')
mtcars$weight_class
cond <- mtcars$wt > 3.5
mtcars$weight_class <- ifelse(cond, 'heavy', mtcars$weight_class)
mtcars$weight_class
View(mtcars)
rm(efficient)
install.packages('knitr', dependencies = T)
library(knitr)
install.packages("knitr", dependencies = T)
subset(mtcars,mpg>=30|hp<60)
getwd()
setwd("~/R Learning/eda-course-materials/lesson2")
read.csv("reddit.csv")
reddit<-read.csv("reddit.csv")
View(reddit)
names(reddit)
table(reddit$employment.status)
str(reddit)
levels(reddit$age.range)
install.packages('ggplot2', dependencies = T)
library(ggplot2)
qplot(data=reddit, x=age.range)
qplot(data=reddit, ordered(x=age.range)
)
qplot(data=reddit, ordered(age.range))
reddit$age.range<-as.ordered(reddit$age.range)
qplot(data=reddit, x=age.range)
levels(age.range)
levels(reddit$age.range)
reddit$age.range<-as.ordered(reddit$age.range,levels(reddit$age.range))
reddit$age.range<-as.ordered(reddit$age.range,levels("Under 18", "18-24", "25-34", "35-44", "45-54", "55-64", "65 or Above" ))
reddit$age.range<-as.ordered(reddit$age.range,levels=c("Under 18", "18-24", "25-34", "35-44", "45-54", "55-64", "65 or Above" ))
reddit$age.range<-ordered(reddit$age.range,levels=c("Under 18", "18-24", "25-34", "35-44", "45-54", "55-64", "65 or Above" ))
qplot(data=reddit, x=age.range)
setwd("~/R Learning/eda-course-materials/lesson3")
pf<-read.csv("pseudo_facebook.tsv)
pf<-read.csv("pseudo_facebook.tsv")
head(pf)
pf<-read.csv("pseudo_facebook.tsv",sep='\t')
head(pf)
names(pf)
qplot(data=pf,bob_month)
qplot(data=pf,dob_month)
qplot(data=pf,dob_day)
qplot(data=pf,dob_day)+
scale_x_continuous(breaks = 1:31)
qplot(data=pf,dob_day)
scale_x_continuous(breaks = 1:31)
qplot(data=pf,dob_day)+
scale_x_continuous(breaks = 1:31)
ggplot(data = pf, aes(x = dob_day)) +
geom_histogram(binwidth = 1) +
scale_x_continuous(breaks = 1:31) +
facet_wrap(~dob_month)
cars<-data(mtcars)
cars<-load(mtcars)
summary(mtcars)
cars<-mtcars
names(cars)
str(cars)
View(cars)
head(cars)
tail(cars)
scatter.smooth(x=cars$mpg, y=cars$wt, main="Dist ~ Speed")
par(mfrow=c(1, 2))  # divide graph area in 2 columns
boxplot(cars$mpg, main="Speed", sub=paste("Outlier rows: ", boxplot.stats(cars$mpg)$out))  # box plot for 'speed'
boxplot(cars$wt, main="Distance", sub=paste("Outlier rows: ", boxplot.stats(cars$wt)$out))  # box plot for 'distance'
summary(cars)
linearMod <- lm(mpg ~ wt, data=cars)  # build linear regression model on full data
summary(linearMod)
(100) # setting seed to reproduce results of random sampling
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData <- cars[-trainingRowIndex, ] # test data
### 然后，用训练数据建立一个模型----------------------------------------------------
lmMod <- lm(dist ~ speed, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
distPred <- predict(lmMod, testData) # predict distance
linearMod <- lm(mpg ~ wt, data=cars)  # build linear regression model on full data
summary(linearMod)
# 4. 小试一下，所谓机器学习
### 首先将数据随机分组成训练用的和测试用的 -------------------------------------------------------
set.seed(100) # setting seed to reproduce results of random sampling
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData <- cars[-trainingRowIndex, ] # test data
### 然后，用训练数据建立一个模型----------------------------------------------------
lmMod <- lm(dist ~ speed, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
distPred <- predict(lmMod, testData) # predict distance
100) # setting seed to reproduce results of random sampling
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData <- cars[-trainingRowIndex, ] # test data
### 然后，用训练数据建立一个模型----------------------------------------------------
lmMod <- lm(mpg ~ wt, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
distPred <- predict(lmMod, testData) # predict distance
###检验一下，我们的预测效果
actuals_preds <- data.frame(cbind(actuals=testData$dist, predicteds=distPred)) # make actuals_predicteds dataframe.
correlation_accura
correlation_accuracy <- cor(actuals_preds) # 82.7%
correlation_accuracy
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 82.7%
correlation_accuracy
actuals_preds <- data.frame(cbind(actuals=testData$dist, predicteds=distPred)) # make actuals_predicteds dataframe.
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 82.7%
correlation_accuracy
d <- predict(lmMod, testData) # predict distance
###检验一下，我们的预测效果
actuals_preds <- data.frame(cbind(actuals=testData$mpg, predicteds=mpgPred)) # make actuals_predicteds dataframe.
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 82.7%
correlation_accuracy
lmMod <- lm(mpg ~ wt, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
mpgPred <- predict(lmMod, testData) # predict distance
###检验一下，我们的预测效果
actuals_preds <- data.frame(cbind(actuals=testData$mpg, predicteds=mpgPred)) # make actuals_predicteds dataframe.
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 82.7%
correlation_accuracy
cars<-mtcars
names(cars)
str(cars)
head(cars)
tail(cars)
summary(cars)
# 2. 对感兴趣的变量做进一步观察，异常值
scatter.smooth(x=cars$mpg, y=cars$wt, main="Dist ~ Speed")
par(mfrow=c(1, 2))  # divide graph area in 2 columns
boxplot(cars$mpg, main="Speed", sub=paste("Outlier rows: ", boxplot.stats(cars$mpg)$out))  # box plot for 'speed'
boxplot(cars$wt, main="Distance", sub=paste("Outlier rows: ", boxplot.stats(cars$wt)$out))  # box plot for 'distance'
# 3. 线性回归
linearMod <- lm(mpg ~ wt, data=cars)  # build linear regression model on full data
summary(linearMod)
# 4. 小试一下，所谓机器学习
### 首先将数据随机分组成训练用的和测试用的 -------------------------------------------------------
set.seed(100) # setting seed to reproduce results of random sampling
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData <- cars[-trainingRowIndex, ] # test data
### 然后，用训练数据建立一个模型----------------------------------------------------
lmMod <- lm(mpg ~ wt, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
mpgPred <- predict(lmMod, testData) # predict distance
###检验一下，我们的预测效果
actuals_preds <- data.frame(cbind(actuals=testData$mpg, predicteds=mpgPred)) # make actuals_predicteds dataframe.
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 84.5%
correlation_accuracy
cars<-mtcars
names(cars)
str(cars)
head(cars)
tail(cars)
summary(cars)
# 2. 对感兴趣的变量做进一步观察，异常值
scatter.smooth(x=cars$mpg, y=cars$wt, main="Dist ~ Speed")
par(mfrow=c(1, 2))  # divide graph area in 2 columns
boxplot(cars$mpg, main="Speed", sub=paste("Outlier rows: ", boxplot.stats(cars$mpg)$out))  # box plot for 'speed'
boxplot(cars$wt, main="Distance", sub=paste("Outlier rows: ", boxplot.stats(cars$wt)$out))  # box plot for 'distance'
# 3. 线性回归
linearMod <- lm(mpg ~ wt, data=cars)  # build linear regression model on full data
summary(linearMod)
# 4. 小试一下，所谓机器学习
### 首先将数据随机分组成训练用的和测试用的 -------------------------------------------------------
set.seed(100) # setting seed to reproduce results of random sampling
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData <- cars[-trainingRowIndex, ] # test data
### 然后，用训练数据建立一个模型----------------------------------------------------
lmMod <- lm(mpg ~ wt, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
mpgPred <- predict(lmMod, testData) # predict distance
###检验一下，我们的预测效果
actuals_preds <- data.frame(cbind(actuals=testData$mpg, predicteds=mpgPred)) # make actuals_predicteds dataframe.
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 84.5%
correlation_accuracy
cars<-mtcars
names(cars)
str(cars)
head(cars)
tail(cars)
summary(cars)
# 2. 对感兴趣的变量做进一步观察，异常值
scatter.smooth(x=cars$mpg, y=cars$wt, main="Dist ~ Speed")
par(mfrow=c(1, 2))  # divide graph area in 2 columns
boxplot(cars$mpg, main="Speed", sub=paste("Outlier rows: ", boxplot.stats(cars$mpg)$out))  # box plot for 'speed'
boxplot(cars$wt, main="Distance", sub=paste("Outlier rows: ", boxplot.stats(cars$wt)$out))  # box plot for 'distance'
# 3. 线性回归
linearMod <- lm(mpg ~ wt, data=cars)  # build linear regression model on full data
summary(linearMod)
# 4. 小试一下，所谓机器学习
### 首先将数据随机分组成训练用的和测试用的 -------------------------------------------------------
set.seed(100) # setting seed to reproduce results of random sampling
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData <- cars[-trainingRowIndex, ] # test data
### 然后，用训练数据建立一个模型----------------------------------------------------
lmMod <- lm(mpg ~ wt, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
mpgPred <- predict(lmMod, testData) # predict distance
###检验一下，我们的预测效果
actuals_preds <- data.frame(cbind(actuals=testData$mpg, predicteds=mpgPred)) # make actuals_predicteds dataframe.
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 84.5%
correlation_accuracy
cars<-mtcars
names(cars)
str(cars)
head(cars)
tail(cars)
summary(cars)
# 2. 对感兴趣的变量做进一步观察，异常值
scatter.smooth(x=cars$mpg, y=cars$wt, main="Dist ~ Speed")
par(mfrow=c(1, 2))  # divide graph area in 2 columns
boxplot(cars$mpg, main="Speed", sub=paste("Outlier rows: ", boxplot.stats(cars$mpg)$out))  # box plot for 'speed'
boxplot(cars$wt, main="Distance", sub=paste("Outlier rows: ", boxplot.stats(cars$wt)$out))  # box plot for 'distance'
# 3. 线性回归
linearMod <- lm(mpg ~ wt, data=cars)  # build linear regression model on full data
summary(linearMod)
# 4. 小试一下，所谓机器学习
### 首先将数据随机分组成训练用的和测试用的 -------------------------------------------------------
set.seed(100) # setting seed to reproduce results of random sampling
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData <- cars[-trainingRowIndex, ] # test data
### 然后，用训练数据建立一个模型----------------------------------------------------
lmMod <- lm(mpg ~ wt, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
mpgPred <- predict(lmMod, testData) # predict distance
###检验一下，我们的预测效果
actuals_preds <- data.frame(cbind(actuals=testData$mpg, predicteds=mpgPred)) # make actuals_predicteds dataframe.
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 84.5%
correlation_accuracy
cars<-mtcars
names(cars)
str(cars)
head(cars)
tail(cars)
summary(cars)
# 2. 对感兴趣的变量做进一步观察，异常值
scatter.smooth(x=cars$mpg, y=cars$wt, main="Dist ~ Speed")
par(mfrow=c(1, 2))  # divide graph area in 2 columns
boxplot(cars$mpg, main="Speed", sub=paste("Outlier rows: ", boxplot.stats(cars$mpg)$out))  # box plot for 'speed'
boxplot(cars$wt, main="Distance", sub=paste("Outlier rows: ", boxplot.stats(cars$wt)$out))  # box plot for 'distance'
# 3. 线性回归
linearMod <- lm(mpg ~ wt, data=cars)  # build linear regression model on full data
summary(linearMod)
# 4. 小试一下，所谓机器学习
### 首先将数据随机分组成训练用的和测试用的 -------------------------------------------------------
set.seed(100) # setting seed to reproduce results of random sampling
trainingRowIndex <- sample(1:nrow(cars), 0.8*nrow(cars)) # row incices for training data
trainingData <- cars[trainingRowIndex, ] # model training data
testData <- cars[-trainingRowIndex, ] # test data
### 然后，用训练数据建立一个模型----------------------------------------------------
lmMod <- lm(mpg ~ wt, data=trainingData) # build the model
### 再然后，将我们建立的模型用来测试数据上，做预测
mpgPred <- predict(lmMod, testData) # predict distance
###检验一下，我们的预测效果
actuals_preds <- data.frame(cbind(actuals=testData$mpg, predicteds=mpgPred)) # make actuals_predicteds dataframe.
attach(actuals_preds)
correlation_accuracy <- cor(actuals,predicteds) # 84.5%
correlation_accuracy
getwd()
setwd("~/R Teaching")
ine = read.csv("wine.csv")
str(wine)
summary(wine)
cor(wine)
round(cor(wine), 2)
wine = read.csv("wine.csv")
str(wine)
summary(wine)
cor(wine)
round(cor(wine), 2)
wine = read.csv("wine.csv")
str(wine)
summary(wine)
cor(wine)
round(cor(wine), 2)
head(wine)
model1 = lm(Price ~ AGST, data = wine)
model1
wineReordered = wine[c("Price", "Year", "WinterRain", "AGST", "HarvestRain", "Age", "FrancePop")] round(cor(wineReordered), 2)
wineReordered = wine[c("Price", "Year", "WinterRain", "AGST", "HarvestRain", "Age", "FrancePop")]
round(cor(wineReordered), 2)
round(cor(wine), 2)
model1 = lm(Price ~ AGST, data = wine)
model1
summary(model1)
ls(model1)
model1$residuals
model1$qr
summary(model1)
model2 = lm(Price ~ AGST + HarvestRain, data = wine)
summary(model2)
model3 = lm(Price ~ AGST + HarvestRain + WinterRain + Age + FrancePop, data = wine)
summary(model3)
model4 = lm(Price ~ AGST + HarvestRain + WinterRain + Age, data = wine)
summary(model4)
wineTest = read.csv("wine_test.csv")
str(wineTest)
predictTest = predict(model4, newdata = wineTest)
predictTest
View(wineTest)
SSE = sum((wineTest$Price - predictTest)^2)
SST = sum((wineTest$Price - mean(wine$Price))^2) 1 - SSE/SST
SST = sum((wineTest$Price - mean(wine$Price))^2)
1 - SSE/SST
setwd("~/R Teaching")
wine = read.csv("wine.csv")
View(wine)
View(wine)
head(wine)
str(wine)
summary(wine)
summary(wine$Year)
cor(wine)
# 1. 读取数据，做基本观察
wine = read.csv("wine.csv")
round(cor(wine), 2)
wineReordered = wine[c("Price", "Year", "WinterRain", "AGST", "HarvestRain", "Age", "FrancePop")]
round(cor(wineReordered), 2)
head(wine)
str(wine)
summary(wine$Year)
model1 = lm(Price ~ AGST, data = wine)
model1
summary(model1)
model2 = lm(Price ~ AGST + HarvestRain, data = wine)
summary(model2)
model3 = lm(Price ~ AGST + HarvestRain + WinterRain + Age + FrancePop, data = wine)
summary(model3)
model4 = lm(Price ~ AGST + HarvestRain + WinterRain + Age, data = wine)
summary(model4)
wineTest = read.csv("wine_test.csv")
str(wineTest)
View(wineTest)
predictTest = predict(model3, newdata = wineTest)
predictTest
SSE = sum((wineTest$Price - predictTest)^2)
SST = sum((wineTest$Price - mean(wine$Price))^2)
1 - SSE/SST
